---
layout: post
title: "日志打印规范：Python"
date: 2025-12-10
categories: [transformer, Attention]
---

## 引言
为什么不使用`print`而使用`logging`呢？首先`print`不支持切换日志等级，会导致在生产环境中产生一些不必要的调试信息；其次，`print`只能输出标准输出、只能输出内容，无法输出到控制台、文件、网络等地方，无法输出包含时间戳、文件名、函数名等能快速定位的日志元信息；最后，`print`性能开销比较大，涉及I/O阻塞。

> 标准输出是一个输出输出的通道，本质是一种数据流/抽象文件描述符，编号为1；可重定向到文件或者管道，默认重定向到终端

## 核心算法中的日志级别使用策略

| 级别 | 目的 | 打印内容 | 打印时机 |
| ---- | ---- | ---- | ---- |
| debug | 最详细的调试信息 | 变量值、循环索引、递归深度、中间计算结果| 尽在开发/调试阶段，追踪算法细节|
| info | 算法执行的关键阶段和里程碑 | 算法开始、结束、数据加载完成、模型加载完成、训练轮次开始、结束| 每次成功到达一个重要阶段时|
| warning | 潜在问题或不理想的状态，但不影响继续执行 | 输入数据不规范、参数超出推荐范围、收敛速度过慢、数据集中出现缺失值 | 算法发现异常但是不中断 |
| error | 导致当前模块、函数无法完成的严重错误 | 外部API调用失败、失败读写失败、关键输出数据类型错误 | 发生局部性错误但是程序主体还在运行 |
| critical | 导致整个程序退出的致命错误 | 内存溢出、配置加载失败 | 依赖的外部服务不可用 | 发生全局性、不可恢复的错误时 |

## 最佳实践
1. 步骤一： 基础配置
   首先，在程序的入口点进行一次性配置

   ```python
   import logging
   import time

   LOG_FORMAT = (
    "%s(sasctime)s | %(levelname)s | %(name)s | "
    "%(filename)s:%(lineno)d | %(message)s
   )

   logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)

   core_logger = logging.getLogger("CORE_ALGORITHM")

   core_logger.setLevel(logging.DEBUG)
   ```

2. 步骤二:在核心代码中打印日志
   ```python
   def optimize_algorithm(data: list, max_iterations: int):
    """一个模拟的迭代优化算法核心函数。"""
    
    # --- INFO 级别：记录算法关键阶段 ---
    core_logger.info("--- 优化算法开始执行 ---")
    core_logger.info(f"输入数据量: {len(data)}, 最大迭代次数: {max_iterations}")

    current_loss = float('inf')
    
    for i in range(max_iterations):
        # 模拟计算
        time.sleep(0.01)
        
        # 模拟中间结果更新
        if i % 5 == 0:
            # --- DEBUG 级别：记录详细的迭代信息（仅在 DEBUG 启用时可见） ---
            current_loss *= 0.8
            core_logger.debug(f"迭代 {i}/{max_iterations}: 中间损失值 (loss) = {current_loss:.4f}")
        
        # 模拟警告情况
        if i > max_iterations / 2 and current_loss > 100:
            # --- WARNING 级别：提醒潜在问题 ---
            core_logger.warning("损失值收敛异常缓慢，可能需要调整学习率。")
        
        # 模拟错误情况
        if data is None:
            # --- ERROR 级别：致命的局部错误 ---
            core_logger.error("输入数据为 None，无法继续计算！")
            return None # 提前退出函数

        # --- INFO 级别：记录算法结束 ---
        core_logger.info(f"--- 算法执行完毕，最终损失值: {current_loss:.4f} ---")
        return current_loss

    optimize_algorithm(data=[1, 2, 3] * 10, max_iterations=20)
   ```

## 有必要知道的事情
1. 单例保证共享：只要名称相同，所有模块都会引用内存中的同一个logger对象，从而共享在main.py中设置的格式、级别和处理器
2. 细粒度控制：使用不同的名称，可以为程序的不同部分设置不同的日志级别